class unbc(Dataset):
    def __init__(self, root_dir, csv_file, indx, transform=None):
        self.data = []
        self.root_dir = root_dir
        self.transform = transform

        # Read the CSV file with format: index, image_path, label
        with open(csv_file, 'r') as csvfile:
            #csvreader = csv.reader(csvfile)
            csvreader = csv.reader(csvfile, delimiter=';')
            for row in csvreader:
                index = int(row[0])
                if index in indx:
                    self.data.append(row)

    def __len__(self):
        return len(self.data)

    def __getitem__(self, idx):
        img_path = os.path.join(self.root_dir, self.data[idx][1])
        image = Image.open(img_path)
        label = int(self.data[idx][2])
        
        if self.transform:
            image = self.transform(image)

        return image, label  # Return a tuple containing image, label, and index



def get_dataset(args):
    """ Returns train and test datasets and a user group which is a dict where
    the keys are the user index and the values are the corresponding data for
    each of those users.
    """

    root_dir = '/Users/jmejia/Thesis/video'

    data_dir = '/Users/jmejia/Thesis/video/Bio_path_def2.csv'

    # Define the total number of samples
    total_samples = 60
    # Generate a list of all indices
    all_indices = list(range(1, total_samples + 1))
      
    # Randomly select 5 indices for the test set
    test_indices = random.sample(all_indices, 12)
    # Remove the selected test indices from the list of all indices
    train_indices = [idx for idx in all_indices if idx not in test_indices]
      
    apply_transform = transforms.Compose([
            transforms.Grayscale(num_output_channels=1),  # Add this line for grayscale conversion
            transforms.ToTensor(),
        ])
    train_dataset = unbc(root_dir, data_dir, train_indices, transform=apply_transform)
    test_dataset = unbc(root_dir, data_dir,test_indices, transform=apply_transform)

      
    print(f"Training Groups: {train_indices}")
    print(f"Testing Groups: {test_indices}")
    print(f"Number of Training Samples: {len(train_dataset)}")
    print(f"Number of Testing Samples: {len(test_dataset)}")
    print()

    return train_dataset, test_dataset





if __name__ == '__main__':
    args = args_parser()
    if args.gpu:
        torch.cuda.set_device(args.gpu)
    device = 'cuda' if args.gpu else 'cpu'

    # load datasets
    train_dataset, test_dataset, _ = get_dataset(args)

    # BUILD MODEL
    global_model = CNNUnbc(args=args)
    
    # Set the model to train and send it to device.
    global_model.to(device)
    global_model.train()
    print(global_model)

    # Training
    # Set optimizer and criterion
    if args.optimizer == 'sgd':
        optimizer = torch.optim.SGD(global_model.parameters(), lr=args.lr,
                                    momentum=0.5)
    elif args.optimizer == 'adam':
        optimizer = torch.optim.Adam(global_model.parameters(), lr=args.lr,
                                     weight_decay=1e-4)

    trainloader = DataLoader(train_dataset, batch_size=64, shuffle=True)
    criterion = torch.nn.NLLLoss().to(device)
    epoch_loss = []

    for epoch in tqdm(range(args.epochs)):
        batch_loss = []

        for batch_idx, (images, labels) in enumerate(trainloader):
            images, labels = images.to(device), labels.to(device)

            optimizer.zero_grad()
            outputs = global_model(images)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()

            if batch_idx % 50 == 0:
                print('Train Epoch: {} [{}/{} ({:.0f}%)]\tLoss: {:.6f}'.format(
                    epoch+1, batch_idx * len(images), len(trainloader.dataset),
                    100. * batch_idx / len(trainloader), loss.item()))
            batch_loss.append(loss.item())

        loss_avg = sum(batch_loss)/len(batch_loss)
        print('\nTrain loss:', loss_avg)
        epoch_loss.append(loss_avg)

    # Plot loss
    plt.figure()
    plt.plot(range(len(epoch_loss)), epoch_loss)
    plt.xlabel('epochs')
    plt.ylabel('Train loss')
    

    # testing
    test_acc, test_loss, true_labels, pred_labels, f1 = test_inference(args, global_model, test_dataset)
    # Calculate other metrics
    report = classification_report(true_labels, pred_labels)
    conf_matrix = confusion_matrix(true_labels, pred_labels)

    print(f' \n Results after {args.epochs} global rounds of training:')
    print("|---- Test Accuracy: {:.2f}%".format(100*test_acc))
    print("|---- F1 Score: {:.2f}".format(f1))
    print("\n")
    print("Detailed F1 Report:")
    print(report)
    print("\nConfusion Matrix:")
    print(conf_matrix)